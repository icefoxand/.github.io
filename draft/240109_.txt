# 안드로이드 개요

	- 스마트폰과 태블릿 컴퓨터에서 사용되는 오픈소스 모바일 OS
	- 플랫폼이기도 함
	- 운영체제, 미들웨어, 사용자인터페이스UI, 표준응용프로그램(웹 브라우저, 이메일 클라이언트, 단문메시지 서비스, 멀티미디어 메시지 서비스 등)을 포함한 소프트웨어 스택이자 모바일 운영체제
	- 초기엔 java로 개발 했으나 오라클과의 법적 분쟁 등으로 현재는 구글의 kotlin 으로 많이 대체됨
	- 안드 OS의 핵심 커널은 리눅스 기반
	- 안드 스튜디오 통해서 개발
	- 안드 플랫폼을 탑재한 다양한 제조사 단말이 출시되었음.. open handset alliance

# 안드로이드 플랫폼(의) 아키텍쳐

	- 리눅스 커널: 보안, 메모리 관리, 프로세스 관리, 파일시스템 관리, 파워 관리, 네트워크 스택, 하드웨어 드라이버 등 하드웨어를 지원(사용자 기반 권한 모델, 프로세스 격리, 안전한 IPC(프로세스간 통신)를 위한 확장 가능한 메커니즘, 커널의 불필요하거나 안전하지 않은 부분을 제거하는 기능
	- HAL(Hardware Abstraction Layer 하드웨어 추상화 계층): 상위 수준의 'java api 프레임워크'에 기기 하드웨어 기능을 노출 시키는 표준 인터페이스임. 
	HAL은 여러 라이브러리 모듈(네이티브 C/C++ 라이브러리)로 구성됨. 
	카메라, 블루투스 모듈 과 같은 특정 유형의 하드웨어 구성 요소를 위한 인터페이스를 구현.
	프레임워크 API가 기기 h/w에 액세스 하기 위해 호출을 수행시, 안드 시스템이 해당 h/w 구성 요소에 대한 라이브러리 모듈을 로드

- API 프레임워크에서 매니저 들을 통해서 아랫단 과 소통하게 됨. 내부 내용을 알기는 어려움.

# 컴포넌트: 

	1. 액티비티 activity: UI 구성을 위한 컴포넌트. 화면 만들기용.
	2. 서비스 service: UI 없이 bg에서 수행하는 컴포넌트. 화면과 무관한 로직용 컴포넌트.
	3. 브로드캐스트 리시버 broadcast receiver: 이벤트로 수행되는(방송을 수신하는?) 컴포넌트. 시스템에서 배터리가 부족하다는 이벤트 발생 -> 이벤트를 수신하는 컴포넌트
	4. 컨텐트 프로바이더 content provider: 어플리케이션 간 데이터 공유를 위한 컴포넌트. 이해하기 힘든 종류의 컴포넌트... 어렵.
	vs content resolver(실상 주로 쓰게 되는 컴포넌트. 사용자 입장에서 주로 사용. 데이터를 받는 입장)

- 컴포넌트란 앱 내에서 독립적인 실행 단위. 
	
	so, 직접 코드로 결합해서 시행하는게 아니고,
	컴포넌트 간에 'intent'(의도) 라는 특정 클래스를 매개로 하여
	미결합 상태로 실행하는 구조.

- "클래스"와 달리 컴포넌트의 '생명주기'는, 안드 시스템이 자체 관리함.

- Main 함수와 같은 애플리케이션의 진입 지점이 따로 없음. 
	- '런쳐'(휴대폰의 가장 처음 배경화면을 의미하는듯?)의 아이콘을 클릭해서 실행하면, 최초 시작인 경우 메인화면이 보임. 
	- 혹은, 알림을 눌러 진입하면, 이때는 해당 알림이 원하는 화면이 보이게 됨.

----
Q. lifecycle 관리를 누가하는가..? spring의 경우 spring framework가 함.

- 안드 앱마다 vm(virtual machine)이 다름.
- 엔디안 처리 문제(서로 소통하기 위해서 어느 방향을 읽는지의 문제)
- a idl 을 이용하여 앱 간에 서로 통신을 함.
----
# JVM_Java Virtual Machine_자바가상머신: Write Once and Run Anywhere <= 이식성 굿굿

.java(source Code) =>=> javac(compiler) =>=> .class(byte code) =>=> JVM1(<-인터프리터 for Mac), JVM2(<-인터프리터 for 윈도우즈), JVM3(<-인터프리터 for 리눅스)

JVM을 따라한 DVM (dalvik virtual machine) 달빅 가상머신
.java => .class => .dex => APK(Resource, .dex):

안드 2.2 이후엔 JIT 컴파일러로 처음 적용(자주 사용하는 부분에 대해 미리 컴파일 하여 기계어로 해석 해놓음. 실행 성능을 향상 시킬수 있음. 실행시 인터프리팅을 시작함)

안드 4.4(API 19) 부턴 'ART(android run time)'를 도입. DVM과 선택적 사용. 
	 AOT(Ahead Of Time)컴파일러를 사용. 
	설치시점에 이미 컴파일 완료. 
	기계어로 해석 끝냄. 실행시 곧바로 기계어 실행.

안드 5.0(API 21) 이후로 기본 런타임으로 지정됨. 

안드 7.0 이후로는 AOT + JIT
----
DVM: JIT. 앱 실행시 컴파일. 설치시 컴파일을 하지 않으므로 AOT보다 설치속도 빠르고, 실행시 컴파일을 하므로 실행속도는 더 느림, 용량작음.
ART: AOT. 앱 설치시 컴파일. 설치시 더 느리고 실행시 더 빠름. 용량큼.(미리 컴파일 하여 가지고 있으므로)

JVM 대신 ART 쓰는 이유? 1. 라이선스 문제 2. 모바일 환경 최적화(배터리, 컴퓨팅파워, 메모리제약)
----
플라밍고 버전(이전) vs 지래프 버전(현재).. 플라밍고 버전이 추천됨
----
AndroidManifest.xml: 앱의 메인 환경 파일
MainActivity.java: 화면 구성을 위한 activity 컴포넌트로, 실제 이 파일이 수행되어서 화면에 UI가 출력됨
res(디렉토리): 
- drawble: 리소스 중 이미지 파일을 저장하기 위한 폴더
- layout: 리소스 중 UI 구성을 위한 레이아웃 xml 파일을 위한 폴더
- mipmap: 리소스 중 앱의 아이콘 이미지를 위한 폴더
- values: 리소스 중 문자열 값 등을 위한 폴더